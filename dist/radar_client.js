var RadarClient =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/backoff.js":
/*!************************!*\
  !*** ./lib/backoff.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Backoff () {\n  this.failures = 0\n}\n\nBackoff.durations = [1000, 2000, 4000, 8000, 16000, 32000] // seconds (ticks)\nBackoff.fallback = 60000\nBackoff.maxSplay = 5000\n\nBackoff.prototype.get = function () {\n  var splay = Math.ceil(Math.random() * Backoff.maxSplay)\n  return splay + (Backoff.durations[this.failures] || Backoff.fallback)\n}\n\nBackoff.prototype.increment = function () {\n  this.failures++\n}\n\nBackoff.prototype.success = function () {\n  this.failures = 0\n}\n\nBackoff.prototype.isUnavailable = function () {\n  return Backoff.durations.length <= this.failures\n}\n\nmodule.exports = Backoff\n\n\n//# sourceURL=webpack://RadarClient/./lib/backoff.js?");

/***/ }),

/***/ "./lib/client_version.js":
/*!*******************************!*\
  !*** ./lib/client_version.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Auto-generated file, overwritten by scripts/add_package_version.js\n\nfunction getClientVersion () { return '0.16.6' }\n\nmodule.exports = getClientVersion\n\n\n//# sourceURL=webpack://RadarClient/./lib/client_version.js?");

/***/ }),

/***/ "./lib/index.js":
/*!**********************!*\
  !*** ./lib/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Client = __webpack_require__(/*! ./radar_client */ \"./lib/radar_client.js\")\nvar instance = new Client()\nvar Backoff = __webpack_require__(/*! ./backoff.js */ \"./lib/backoff.js\")\n\ninstance._log = __webpack_require__(/*! minilog */ \"minilog\")\ninstance.Backoff = Backoff\n\n// This module makes radar_client a singleton to prevent multiple connections etc.\n\nmodule.exports = instance\n\n\n//# sourceURL=webpack://RadarClient/./lib/index.js?");

/***/ }),

/***/ "./lib/radar_client.js":
/*!*****************************!*\
  !*** ./lib/radar_client.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* globals setImmediate */\nvar MicroEE = __webpack_require__(/*! microee */ \"./node_modules/microee/index.js\")\nvar eio = __webpack_require__(/*! engine.io-client */ \"engine.io-client\")\nvar Scope = __webpack_require__(/*! ./scope.js */ \"./lib/scope.js\")\nvar StateMachine = __webpack_require__(/*! ./state.js */ \"./lib/state.js\")\nvar immediate = typeof setImmediate !== 'undefined' ? setImmediate : function (fn) { setTimeout(fn, 1) }\nvar getClientVersion = __webpack_require__(/*! ./client_version.js */ \"./lib/client_version.js\")\nvar Request = __webpack_require__(/*! radar_message */ \"./node_modules/radar_message/lib/index.js\").Request\nvar Response = __webpack_require__(/*! radar_message */ \"./node_modules/radar_message/lib/index.js\").Response\n\nfunction Client (backend) {\n  this.logger = __webpack_require__(/*! minilog */ \"minilog\")('radar_client')\n  this._ackCounter = 1\n  this._channelSyncTimes = {}\n  this._uses = {}\n  this._presences = {}\n  this._subscriptions = {}\n  this._restoreRequired = false\n  this._queuedRequests = []\n  this._identitySetRequired = true\n  this._isConfigured = false\n\n  this._createManager()\n  this.configure(false)\n  this._addListeners()\n\n  // Allow backend substitution for tests\n  this.backend = backend || eio\n}\n\nMicroEE.mixin(Client)\n\n// Public API\n\n// Each use of the client is registered with \"alloc\", and a given use often\n// persists through many connects and disconnects.\n// The state machine - \"manager\" - handles connects and disconnects\nClient.prototype.alloc = function (useName, callback) {\n  var self = this\n  if (!this._uses[useName]) {\n    this.logger().info('alloc: ', useName)\n    this.once('ready', function () {\n      self.logger().info('ready: ', useName)\n    })\n\n    this._uses[useName] = true\n  }\n\n  callback && this.once('ready', function () {\n    if (Object.prototype.hasOwnProperty.call(self._uses, useName)) {\n      callback()\n    }\n  })\n\n  if (this._isConfigured) {\n    this.manager.start()\n  } else {\n    this._waitingForConfigure = true\n  }\n\n  return this\n}\n\n// When done with a given use of the client, unregister the use\n// Only when all uses are unregistered do we disconnect the client\nClient.prototype.dealloc = function (useName) {\n  this.logger().info({ op: 'dealloc', useName: useName })\n\n  delete this._uses[useName]\n\n  var stillAllocated = false\n  var key\n\n  for (key in this._uses) {\n    if (Object.prototype.hasOwnProperty.call(this._uses, key)) {\n      stillAllocated = true\n      break\n    }\n  }\n  if (!stillAllocated) {\n    this.logger().info('closing the connection')\n    this.manager.close()\n  }\n}\n\nClient.prototype.currentState = function () {\n  return this.manager.current\n}\n\nClient.prototype.configure = function (hash) {\n  var configuration = hash || this._configuration || { accountName: '', userId: 0, userType: 0 }\n  configuration.userType = configuration.userType || 0\n  this._configuration = this._me = configuration\n  this._isConfigured = this._isConfigured || !!hash\n\n  if (this._isConfigured && this._waitingForConfigure) {\n    this._waitingForConfigure = false\n    this.manager.start()\n  }\n\n  return this\n}\n\nClient.prototype.configuration = function (configKey) {\n  if (configKey in this._configuration) {\n    return JSON.parse(JSON.stringify(this._configuration[configKey]))\n  } else {\n    return null\n  }\n}\n\nClient.prototype.attachStateMachineErrorHandler = function (errorHandler) {\n  this.manager.attachErrorHandler(errorHandler)\n}\n\nClient.prototype.currentUserId = function () {\n  return this._configuration && this._configuration.userId\n}\n\nClient.prototype.currentClientId = function () {\n  return this._socket && this._socket.id\n}\n\n// Return the chainable scope object for a given message type\n\nClient.prototype.message = function (scope) {\n  return new Scope('message', scope, this)\n}\n\nClient.prototype.presence = function (scope) {\n  return new Scope('presence', scope, this)\n}\n\nClient.prototype.status = function (scope) {\n  return new Scope('status', scope, this)\n}\n\nClient.prototype.stream = function (scope) {\n  return new Scope('stream', scope, this)\n}\n\nClient.prototype.control = function (scope) {\n  return new Scope('control', scope, this)\n}\n\n// Operations\n\nClient.prototype.nameSync = function (scope, options, callback) {\n  var request = Request.buildNameSync(scope, options)\n  return this._write(request, callback)\n}\n\nClient.prototype.push = function (scope, resource, action, value, callback) {\n  var request = Request.buildPush(scope, resource, action, value)\n  return this._write(request, callback)\n}\n\nClient.prototype.set = function (scope, value, clientData, callback) {\n  var request\n\n  callback = _chooseFunction(clientData, callback)\n  clientData = _nullIfFunction(clientData)\n\n  request = Request.buildSet(scope, value,\n    this._configuration.userId, this._configuration.userType,\n    clientData)\n\n  return this._write(request, callback)\n}\n\nClient.prototype.publish = function (scope, value, callback) {\n  var request = Request.buildPublish(scope, value)\n  return this._write(request, callback)\n}\n\nClient.prototype.subscribe = function (scope, options, callback) {\n  callback = _chooseFunction(options, callback)\n  options = _nullIfFunction(options)\n\n  var request = Request.buildSubscribe(scope, options)\n\n  return this._write(request, callback)\n}\n\nClient.prototype.unsubscribe = function (scope, callback) {\n  var request = Request.buildUnsubscribe(scope)\n  return this._write(request, callback)\n}\n\n// sync returns the actual value of the operation\nClient.prototype.sync = function (scope, options, callback) {\n  var request, onResponse, v1Presence\n\n  callback = _chooseFunction(options, callback)\n  options = _nullIfFunction(options)\n\n  request = Request.buildSync(scope, options)\n\n  v1Presence = !options && request.isPresence()\n  onResponse = function (message) {\n    var response = new Response(message)\n    if (response && response.isFor(request)) {\n      if (v1Presence) {\n        response.forceV1Response()\n      }\n      if (callback) {\n        callback(response.getMessage())\n      }\n      return true\n    }\n    return false\n  }\n\n  this.when('get', onResponse)\n\n  // sync does not return ACK (it sends back a data message)\n  return this._write(request)\n}\n\n// get returns the actual value of the operation\nClient.prototype.get = function (scope, options, callback) {\n  var request\n\n  callback = _chooseFunction(options, callback)\n  options = _nullIfFunction(options)\n\n  request = Request.buildGet(scope, options)\n\n  var onResponse = function (message) {\n    var response = new Response(message)\n    if (response && response.isFor(request)) {\n      if (callback) {\n        callback(response.getMessage())\n      }\n      return true\n    }\n    return false\n  }\n\n  this.when('get', onResponse)\n\n  // get does not return ACK (it sends back a data message)\n  return this._write(request)\n}\n\n// Private API\n\nvar _chooseFunction = function (options, callback) {\n  return typeof (options) === 'function' ? options : callback\n}\n\nvar _nullIfFunction = function (options) {\n  if (typeof (options) === 'function') {\n    return null\n  }\n  return options\n}\n\nClient.prototype._addListeners = function () {\n  // Add authentication data to a request message; _write() emits authenticateMessage\n  this.on('authenticateMessage', function (message) {\n    var request = new Request(message)\n    request.setAuthData(this._configuration)\n\n    this.emit('messageAuthenticated', request.getMessage())\n  })\n\n  // Once the request is authenticated, send it to the server\n  this.on('messageAuthenticated', function (message) {\n    var request = new Request(message)\n    this._sendMessage(request)\n  })\n}\n\nClient.prototype._write = function (request, callback) {\n  var self = this\n\n  if (callback) {\n    request.setAttr('ack', this._ackCounter++)\n\n    // Wait ack\n    this.when('ack', function (message) {\n      var response = new Response(message)\n      self.logger().debug('ack', response)\n      if (!response.isAckFor(request)) { return false }\n      callback(request.getMessage())\n\n      return true\n    })\n  }\n\n  this.emit('authenticateMessage', request.getMessage())\n\n  return this\n}\n\nClient.prototype._batch = function (response) {\n  var to = response.getAttr('to')\n  var value = response.getAttr('value')\n  var time = response.getAttr('time')\n\n  if (!response.isValid()) {\n    this.logger().info('response is invalid:', response.getMessage())\n    return false\n  }\n\n  var index = 0\n  var data\n  var length = value.length\n  var newest = time\n  var current = this._channelSyncTimes[to] || 0\n\n  for (; index < length; index = index + 2) {\n    data = JSON.parse(value[index])\n    time = value[index + 1]\n\n    if (time > current) {\n      this.emitNext(to, data)\n    }\n    if (time > newest) {\n      newest = time\n    }\n  }\n  this._channelSyncTimes[to] = newest\n}\n\nClient.prototype._createManager = function () {\n  var self = this\n  var manager = this.manager = StateMachine.create()\n\n  manager.on('enterState', function (state) {\n    self.emit(state)\n  })\n\n  manager.on('event', function (event) {\n    self.emit(event)\n  })\n\n  manager.on('connect', function (data) {\n    var socket = self._socket = new self.backend.Socket(self._configuration)\n\n    socket.once('open', function () {\n      if (socket !== self._socket) {\n        socket.removeAllListeners('message')\n        socket.removeAllListeners('open')\n        socket.removeAllListeners('close')\n        socket.close()\n        return\n      }\n\n      self.logger().debug('socket open', socket.id)\n      manager.established()\n    })\n\n    socket.once('close', function (reason, description) {\n      self.logger().debug('socket closed', socket.id, reason, description)\n      socket.removeAllListeners('message')\n      // Patch for polling-xhr continuing to poll after socket close (HTTP:POST\n      // failure).  socket.transport is in error but not closed, so if a subsequent\n      // poll succeeds, the transport remains open and polling until server closes\n      // the socket.\n      if (socket.transport) {\n        socket.transport.close()\n      }\n\n      if (socket === self._socket) {\n        self._socket = null\n        if (!manager.is('closed')) {\n          manager.disconnect()\n        }\n      }\n    })\n\n    socket.on('message', function (message) {\n      if (socket !== self._socket) {\n        socket.removeAllListeners('message')\n        socket.removeAllListeners('open')\n        socket.removeAllListeners('close')\n        socket.close()\n        return\n      }\n      self._messageReceived(message)\n    })\n\n    socket.on('error', function (error) {\n      self.emit('socketError', error)\n    })\n\n    manager.removeAllListeners('close')\n    manager.once('close', function () {\n      socket.close()\n    })\n  })\n\n  manager.on('activate', function () {\n    if (self._socket === null) {\n      manager.disconnect()\n    } else {\n      self._identitySet()\n      self._restore()\n      self.emit('ready')\n    }\n  })\n\n  manager.on('authenticate', function () {\n    // Can be overridden in order to establish an authentication protocol\n    manager.activate()\n  })\n\n  manager.on('disconnect', function () {\n    self._restoreRequired = true\n    self._identitySetRequired = true\n\n    var socket = self._socket\n    if (socket) {\n      // If you reach disconnect with a socket obj,\n      // it might be from startGuard (open timeout reached)\n      // Clear out the current attempt to get a socket\n      // and close it if it opens\n      socket.removeAllListeners('message')\n      socket.removeAllListeners('open')\n      socket.removeAllListeners('close')\n      socket.once('open', function () {\n        self.logger().debug('socket open, closing it', socket.id)\n        socket.close()\n      })\n      self._socket = null\n    }\n  })\n\n  manager.on('backoff', function (time, step) {\n    self.emit('backoff', time, step)\n  })\n}\n\n// Memorize subscriptions and presence states; return \"true\" for a message that\n// adds to the memorized subscriptions or presences\nClient.prototype._memorize = function (request) {\n  var op = request.getAttr('op')\n  var to = request.getAttr('to')\n  var value = request.getAttr('value')\n\n  switch (op) {\n    case 'unsubscribe':\n      // Remove from queue\n      if (this._subscriptions[to]) {\n        delete this._subscriptions[to]\n      }\n      return true\n\n    case 'sync':\n    case 'subscribe':\n      // A catch for when *subscribe* is called after *sync*\n      if (this._subscriptions[to] !== 'sync') {\n        this._subscriptions[to] = op\n      }\n      return true\n\n    case 'set':\n      if (request.isPresence()) {\n        if (value !== 'offline') {\n          this._presences[to] = value\n        } else {\n          delete this._presences[to]\n        }\n        return true\n      }\n  }\n\n  return false\n}\n\nClient.prototype._restore = function () {\n  var item\n  var to\n  var counts = { subscriptions: 0, presences: 0, messages: 0 }\n  if (this._restoreRequired) {\n    this._restoreRequired = false\n\n    for (to in this._subscriptions) {\n      if (Object.prototype.hasOwnProperty.call(this._subscriptions, to)) {\n        item = this._subscriptions[to]\n        this[item](to)\n        counts.subscriptions += 1\n      }\n    }\n\n    for (to in this._presences) {\n      if (Object.prototype.hasOwnProperty.call(this._presences, to)) {\n        this.set(to, this._presences[to])\n        counts.presences += 1\n      }\n    }\n\n    while (this._queuedRequests.length) {\n      this._write(this._queuedRequests.shift())\n      counts.messages += 1\n    }\n\n    this.logger().debug('restore-subscriptions', counts)\n  }\n}\n\nClient.prototype._sendMessage = function (request) {\n  var memorized = this._memorize(request)\n  var ack = request.getAttr('ack')\n\n  this.emit('message:out', request.getMessage())\n\n  if (this._socket && this.manager.is('activated')) {\n    this._socket.sendPacket('message', request.payload())\n  } else if (this._isConfigured) {\n    this._restoreRequired = true\n    this._identitySetRequired = true\n    if (!memorized || ack) {\n      this._queuedRequests.push(request)\n    }\n    this.manager.connectWhenAble()\n  }\n}\n\nClient.prototype._messageReceived = function (msg) {\n  var response = new Response(JSON.parse(msg))\n  var op = response.getAttr('op')\n  var to = response.getAttr('to')\n\n  this.emit('message:in', response.getMessage())\n\n  switch (op) {\n    case 'err':\n    case 'ack':\n    case 'get':\n      this.emitNext(op, response.getMessage())\n      break\n\n    case 'sync':\n      this._batch(response)\n      break\n\n    default:\n      this.emitNext(to, response.getMessage())\n  }\n}\n\nClient.prototype.emitNext = function () {\n  var self = this\n  var args = Array.prototype.slice.call(arguments)\n  immediate(function () { self.emit.apply(self, args) })\n}\n\nClient.prototype._identitySet = function () {\n  if (this._identitySetRequired) {\n    this._identitySetRequired = false\n\n    if (!this.name) {\n      this.name = this._uuidV4Generate()\n    }\n\n    // Send msg that associates this.id with current name\n    var association = { id: this._socket.id, name: this.name }\n    var clientVersion = getClientVersion()\n    var options = { association: association, clientVersion: clientVersion }\n    var self = this\n\n    this.control('clientName').nameSync(options, function (message) {\n      self.logger('nameSync message: ' + JSON.stringify(message))\n    })\n  }\n}\n\n// Variant (by Jeff Ward) of code behind node-uuid, but avoids need for module\nvar lut = []\nfor (var i = 0; i < 256; i++) { lut[i] = (i < 16 ? '0' : '') + (i).toString(16) }\nClient.prototype._uuidV4Generate = function () {\n  var d0 = Math.random() * 0xffffffff | 0\n  var d1 = Math.random() * 0xffffffff | 0\n  var d2 = Math.random() * 0xffffffff | 0\n  var d3 = Math.random() * 0xffffffff | 0\n  return lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff] + '-' +\n  lut[d1 & 0xff] + lut[d1 >> 8 & 0xff] + '-' + lut[d1 >> 16 & 0x0f | 0x40] + lut[d1 >> 24 & 0xff] + '-' +\n  lut[d2 & 0x3f | 0x80] + lut[d2 >> 8 & 0xff] + '-' + lut[d2 >> 16 & 0xff] + lut[d2 >> 24 & 0xff] +\n  lut[d3 & 0xff] + lut[d3 >> 8 & 0xff] + lut[d3 >> 16 & 0xff] + lut[d3 >> 24 & 0xff]\n}\n\nClient.setBackend = function (lib) { eio = lib }\n\nmodule.exports = Client\n\n\n//# sourceURL=webpack://RadarClient/./lib/radar_client.js?");

/***/ }),

/***/ "./lib/scope.js":
/*!**********************!*\
  !*** ./lib/scope.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Scope (typeName, scope, client) {\n  this.client = client\n  this.prefix = this._buildScopePrefix(typeName, scope, client.configuration('accountName'))\n}\n\nvar props = ['set', 'get', 'subscribe', 'unsubscribe', 'publish', 'push', 'sync',\n  'on', 'once', 'when', 'removeListener', 'removeAllListeners', 'nameSync']\n\nvar init = function (name) {\n  Scope.prototype[name] = function () {\n    var args = Array.prototype.slice.apply(arguments)\n    args.unshift(this.prefix)\n    this.client[name].apply(this.client, args)\n    return this\n  }\n}\n\nfor (var i = 0; i < props.length; i++) {\n  init(props[i])\n}\n\nScope.prototype._buildScopePrefix = function (typeName, scope, accountName) {\n  return typeName + ':/' + accountName + '/' + scope\n}\n\nmodule.exports = Scope\n\n\n//# sourceURL=webpack://RadarClient/./lib/scope.js?");

/***/ }),

/***/ "./lib/state.js":
/*!**********************!*\
  !*** ./lib/state.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var log = __webpack_require__(/*! minilog */ \"minilog\")('radar_state')\nvar MicroEE = __webpack_require__(/*! microee */ \"./node_modules/microee/index.js\")\nvar Backoff = __webpack_require__(/*! ./backoff */ \"./lib/backoff.js\")\nvar Machine = __webpack_require__(/*! sfsm */ \"./node_modules/sfsm/state-machine.js\")\n\nfunction create () {\n  var backoff = new Backoff()\n  var machine = Machine.create({\n    error: function (name, from, to, args, type, message, err) {\n      log.warn('state-machine-error', arguments)\n\n      if (err) {\n        if (this.errorHandler) {\n          this.errorHandler(name, from, to, args, type, message, err)\n        } else {\n          throw err\n        }\n      }\n    },\n\n    events: [\n      { name: 'connect', from: ['opened', 'disconnected'], to: 'connecting' },\n      { name: 'established', from: 'connecting', to: 'connected' },\n      { name: 'authenticate', from: 'connected', to: 'authenticating' },\n      { name: 'activate', from: ['authenticating', 'activated'], to: 'activated' },\n      { name: 'disconnect', from: Machine.WILDCARD, to: 'disconnected' },\n      { name: 'close', from: Machine.WILDCARD, to: 'closed' },\n      { name: 'open', from: ['none', 'closed'], to: 'opened' }\n    ],\n\n    callbacks: {\n      onevent: function (event, from, to) {\n        log.debug('from ' + from + ' -> ' + to + ', event: ' + event)\n\n        this.emit('event', event)\n        this.emit(event, arguments)\n      },\n\n      onstate: function (event, from, to) {\n        this.emit('enterState', to)\n        this.emit(to, arguments)\n      },\n\n      onconnecting: function () {\n        this.startGuard()\n      },\n\n      onestablished: function () {\n        this.cancelGuard()\n        backoff.success()\n        this.authenticate()\n      },\n\n      onclose: function () {\n        this.cancelGuard()\n      },\n\n      ondisconnected: function (event, from, to) {\n        if (this._timer) {\n          clearTimeout(this._timer)\n          delete this._timer\n        }\n\n        var time = backoff.get()\n        backoff.increment()\n\n        this.emit('backoff', time, backoff.failures)\n        log.debug('reconnecting in ' + time + 'msec')\n\n        this._timer = setTimeout(function () {\n          delete machine._timer\n          if (machine.is('disconnected')) {\n            machine.connect()\n          }\n        }, time)\n\n        if (backoff.isUnavailable()) {\n          log.info('unavailable')\n          this.emit('unavailable')\n        }\n      }\n    }\n  })\n\n  // For testing\n  machine._backoff = backoff\n  machine._connectTimeout = 10000\n\n  for (var property in MicroEE.prototype) {\n    if (Object.prototype.hasOwnProperty.call(MicroEE.prototype, property)) {\n      machine[property] = MicroEE.prototype[property]\n    }\n  }\n\n  machine.open()\n\n  machine.start = function () {\n    if (this.is('closed')) {\n      this.open()\n    }\n\n    if (this.is('activated')) {\n      this.activate()\n    } else {\n      this.connectWhenAble()\n    }\n  }\n\n  machine.startGuard = function () {\n    machine.cancelGuard()\n    machine._guard = setTimeout(function () {\n      log.info('startGuard: disconnect from timeout')\n      machine.disconnect()\n    }, machine._connectTimeout)\n  }\n\n  machine.cancelGuard = function () {\n    if (machine._guard) {\n      clearTimeout(machine._guard)\n      delete machine._guard\n    }\n  }\n\n  machine.connectWhenAble = function () {\n    if (!(this.is('connected') || this.is('activated'))) {\n      if (this.can('connect')) {\n        this.connect()\n      } else {\n        this.once('enterState', function () {\n          machine.connectWhenAble()\n        })\n      }\n    }\n  }\n\n  machine.attachErrorHandler = function (errorHandler) {\n    if (typeof errorHandler === 'function') {\n      this.errorHandler = errorHandler\n    } else {\n      log.warn('errorHandler must be a function')\n    }\n  }\n\n  return machine\n}\n\nmodule.exports = { create: create }\n\n\n//# sourceURL=webpack://RadarClient/./lib/state.js?");

/***/ }),

/***/ "./node_modules/microee/index.js":
/*!***************************************!*\
  !*** ./node_modules/microee/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function M() { this._events = {}; }\nM.prototype = {\n  on: function(ev, cb) {\n    this._events || (this._events = {});\n    var e = this._events;\n    (e[ev] || (e[ev] = [])).push(cb);\n    return this;\n  },\n  removeListener: function(ev, cb) {\n    var e = this._events[ev] || [], i;\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      if(e[i] === cb || e[i].cb === cb) { e.splice(i, 1); }\n    }\n  },\n  removeAllListeners: function(ev) {\n    if(!ev) { this._events = {}; }\n    else { this._events[ev] && (this._events[ev] = []); }\n  },\n  listeners: function(ev) {\n    return (this._events ? this._events[ev] || [] : []);\n  },\n  emit: function(ev) {\n    this._events || (this._events = {});\n    var args = Array.prototype.slice.call(arguments, 1), i, e = this._events[ev] || [];\n    for(i = e.length-1; i >= 0 && e[i]; i--){\n      e[i].apply(this, args);\n    }\n    return this;\n  },\n  when: function(ev, cb) {\n    return this.once(ev, cb, true);\n  },\n  once: function(ev, cb, when) {\n    if(!cb) return this;\n    function c() {\n      if(!when) this.removeListener(ev, c);\n      if(cb.apply(this, arguments) && when) this.removeListener(ev, c);\n    }\n    c.cb = cb;\n    this.on(ev, c);\n    return this;\n  }\n};\nM.mixin = function(dest) {\n  var o = M.prototype, k;\n  for (k in o) {\n    o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);\n  }\n};\nmodule.exports = M;\n\n\n//# sourceURL=webpack://RadarClient/./node_modules/microee/index.js?");

/***/ }),

/***/ "./node_modules/radar_message/lib/batch_message.js":
/*!*********************************************************!*\
  !*** ./node_modules/radar_message/lib/batch_message.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("class Batch {\n  constructor () {\n    const messages = [...arguments]\n    this.value = messages\n    this.op = 'batch'\n  }\n\n  add (message) {\n    this.value.push(message)\n  }\n\n  get length () {\n    return this.value.length\n  }\n\n  toJSON () {\n    return {\n      op: this.op,\n      length: this.length,\n      value: this.value\n    }\n  }\n}\n\nmodule.exports = Batch\n\n\n//# sourceURL=webpack://RadarClient/./node_modules/radar_message/lib/batch_message.js?");

/***/ }),

/***/ "./node_modules/radar_message/lib/index.js":
/*!*************************************************!*\
  !*** ./node_modules/radar_message/lib/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const Request = __webpack_require__(/*! ./message_request */ \"./node_modules/radar_message/lib/message_request.js\")\nconst Response = __webpack_require__(/*! ./message_response */ \"./node_modules/radar_message/lib/message_response.js\")\nconst Batch = __webpack_require__(/*! ./batch_message */ \"./node_modules/radar_message/lib/batch_message.js\")\nconst RadarMessage = {}\n\nRadarMessage.Batch = Batch\nRadarMessage.Request = Request\nRadarMessage.Response = Response\n\nmodule.exports = RadarMessage\n\n\n//# sourceURL=webpack://RadarClient/./node_modules/radar_message/lib/index.js?");

/***/ }),

/***/ "./node_modules/radar_message/lib/message_request.js":
/*!***********************************************************!*\
  !*** ./node_modules/radar_message/lib/message_request.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const logger = __webpack_require__(/*! minilog */ \"minilog\")('message:request')\n\nconst opTable = {\n  control: ['nameSync', 'disconnect'],\n  message: ['publish', 'subscribe', 'sync', 'unsubscribe'],\n  presence: ['get', 'set', 'subscribe', 'sync', 'unsubscribe'],\n  status: ['get', 'set', 'subscribe', 'sync', 'unsubscribe'],\n  stream: ['get', 'push', 'subscribe', 'sync', 'unsubscribe']\n}\n\nconst Request = function (message) {\n  this.message = message\n\n  if (!this._isValid()) {\n    logger.error('invalid request. op: ' + this.message.op + '; to: ' + this.message.to)\n    this.message = {}\n  }\n}\n\nRequest.buildGet = function (scope, options, message = { op: 'get', to: scope }) {\n  return new Request(message).setOptions(options)\n}\n\nRequest.buildPublish = function (scope, value, message = { op: 'publish', to: scope }) {\n  const request = new Request(message)\n  request.setAttr('value', value)\n\n  return request\n}\n\nRequest.buildPush = function (scope, resource, action, value, message = { op: 'push', to: scope }) {\n  const request = new Request(message)\n  request.setAttr('resource', resource)\n  request.setAttr('action', action)\n  request.setAttr('value', value)\n\n  return request\n}\n\nRequest.buildNameSync = function (scope, options, message = { op: 'nameSync', to: scope }) {\n  return new Request(message).setOptions(options)\n}\n\nRequest.buildSet = function (scope, value, key, userType, clientData, message = { op: 'set', to: scope }) {\n  const request = new Request(message)\n  request.setAttr('value', value)\n  request.setAttr('key', key)\n  request.setAttr('type', userType)\n  if (clientData) {\n    request.setAttr('clientData', clientData)\n  }\n\n  return request\n}\n\nRequest.buildSync = function (scope, options, message = { op: 'sync', to: scope }) {\n  const request = new Request(message).setOptions(options)\n  if (request.isPresence()) {\n    request.forceV2Sync(options)\n  }\n  return request\n}\n\nRequest.buildSubscribe = function (scope, options, message = { op: 'subscribe', to: scope }) {\n  return new Request(message).setOptions(options)\n}\n\nRequest.buildUnsubscribe = function (scope, message = { op: 'unsubscribe', to: scope }) {\n  return new Request(message)\n}\n\n// Instance methods\n\nRequest.prototype.forceV2Sync = function (options = {}) {\n  options = options || {} // options is sometimes null, which would cause an exception on the next line\n  options.version = 2\n  this.setAttr('options', options)\n}\n\nRequest.prototype.setAuthData = function (configuration) {\n  this.setAttr('userData', configuration.userData)\n  if (configuration.auth) {\n    this.setAttr('auth', configuration.auth)\n    this.setAttr('userId', configuration.userId)\n    this.setAttr('userType', configuration.userType)\n    this.setAttr('accountName', configuration.accountName)\n  }\n}\n\nRequest.prototype.getMessage = function () {\n  return this.message\n}\n\nRequest.prototype.setOptions = function (options) {\n  // Keep check for options, since it is sometimes purposefully null\n  if (options) {\n    this.setAttr('options', options)\n  }\n\n  return this\n}\n\nRequest.prototype.isPresence = function () {\n  return this.type === 'presence'\n}\n\nRequest.prototype.setAttr = function (keyName, keyValue) {\n  this.message[keyName] = keyValue\n}\n\nRequest.prototype.getAttr = function (keyName) {\n  return this.message[keyName]\n}\n\nRequest.prototype.payload = function () {\n  return JSON.stringify(this.getMessage())\n}\n\nRequest.prototype.getType = function () {\n  return this.type\n}\n\n// Private methods\n\nRequest.prototype._isValid = function () {\n  if (!this.message.op || !this.message.to) {\n    return false\n  }\n\n  const type = this._getType()\n  if (type) {\n    if (this._isValidType(type) && this._isValidOperation(type)) {\n      this.type = type\n      return true\n    }\n  } else {\n    logger.error('missing type')\n  }\n  return false\n}\n\nRequest.prototype._isValidType = function (type) {\n  for (const key in opTable) {\n    if (Object.prototype.hasOwnProperty.call(opTable, key) && key === type) {\n      return true\n    }\n  }\n  this.errMsg = 'invalid type: ' + type\n  logger.error(this.errMsg)\n  return false\n}\n\nRequest.prototype._isValidOperation = function (type, ops = opTable[type]) {\n  const isValid = ops && ops.indexOf(this.message.op) >= 0\n  if (!isValid) {\n    this.errMsg = 'invalid operation: ' + this.message.op + ' for type: ' + type\n    logger.error(this.errMsg)\n  }\n  return isValid\n}\n\nRequest.prototype._getType = function () {\n  return this.message.to.substring(0, this.message.to.indexOf(':'))\n}\n\nmodule.exports = Request\n\n\n//# sourceURL=webpack://RadarClient/./node_modules/radar_message/lib/message_request.js?");

/***/ }),

/***/ "./node_modules/radar_message/lib/message_response.js":
/*!************************************************************!*\
  !*** ./node_modules/radar_message/lib/message_response.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const logger = __webpack_require__(/*! minilog */ \"minilog\")('message:response')\n\nfunction Response (message) {\n  this.message = message\n\n  if (!this._validate()) {\n    logger.error('invalid response. message: ' + JSON.stringify(message))\n    this.message = {}\n  }\n}\n\nResponse.prototype.getMessage = function () {\n  return this.message\n}\n\nResponse.prototype._validate = function () {\n  if (!this.message.op) {\n    this.errMsg = 'missing op'\n    return false\n  }\n\n  switch (this.message.op) {\n    case 'ack':\n      if (!this.message.value) {\n        this.errMsg = 'missing value'\n        logger.error(this.errMsg)\n        return false\n      }\n      break\n\n    default:\n      if (this.message.op !== 'err' && !this.message.to) {\n        this.errMsg = 'missing to'\n        logger.error(this.errMsg)\n        return false\n      }\n  }\n\n  return true\n}\n\nResponse.prototype.isValid = function () {\n  return !!this.message.to && !!this.message.value && !!this.message.time\n}\n\nResponse.prototype.isFor = function (request) {\n  return this.getAttr('to') === request.getAttr('to')\n}\n\nResponse.prototype.isAckFor = function (request) {\n  return this.getAttr('value') === request.getAttr('ack')\n}\n\nResponse.prototype.getAttr = function (attr) {\n  return this.message[attr]\n}\n\nResponse.prototype.forceV1Response = function () {\n  // Sync v1 for presence scopes is inconsistent: the result should be a 'get'\n  // message, but instead is an 'online' message.  Take a v2 response and\n  // massage it to v1 format prior to returning to the caller.\n  const message = this.message\n  const value = {}\n\n  for (const userId in message.value) {\n    if (Object.prototype.hasOwnProperty.call(message.value, userId)) {\n      // Skip when not defined; causes exception in FF for 'Work Offline'\n      if (!message.value[userId]) { continue }\n      value[userId] = message.value[userId].userType\n    }\n  }\n  message.value = value\n  message.op = 'online'\n\n  this.message = message\n}\n\nmodule.exports = Response\n\n\n//# sourceURL=webpack://RadarClient/./node_modules/radar_message/lib/message_response.js?");

/***/ }),

/***/ "./node_modules/sfsm/state-machine.js":
/*!********************************************!*\
  !*** ./node_modules/sfsm/state-machine.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\n  Javascript State Machine Library - https://github.com/jakesgordon/javascript-state-machine\n\n  Copyright (c) 2012, 2013 Jake Gordon and contributors\n  Released under the MIT license - https://github.com/jakesgordon/javascript-state-machine/blob/master/LICENSE\n\n*/\n\nvar StateMachine = StateMachine = module.exports = {\n\n    //---------------------------------------------------------------------------\n\n    VERSION: '2.2.0',\n\n    //---------------------------------------------------------------------------\n\n    Result: {\n      SUCCEEDED:    1, // the event transitioned successfully from one state to another\n      NOTRANSITION: 2, // the event was successfull but no state transition was necessary\n      CANCELLED:    3, // the event was cancelled by the caller in a beforeEvent callback\n      PENDING:      4  // the event is asynchronous and the caller is in control of when the transition occurs\n    },\n\n    Error: {\n      INVALID_TRANSITION: 100, // caller tried to fire an event that was innapropriate in the current state\n      PENDING_TRANSITION: 200, // caller tried to fire an event while an async transition was still pending\n      INVALID_CALLBACK:   300 // caller provided callback function threw an exception\n    },\n\n    WILDCARD: '*',\n    ASYNC: 'async',\n\n    //---------------------------------------------------------------------------\n\n    create: function(cfg, target) {\n\n      var initial   = (typeof cfg.initial == 'string') ? { state: cfg.initial } : cfg.initial; // allow for a simple string, or an object with { state: 'foo', event: 'setup', defer: true|false }\n      var terminal  = cfg.terminal || cfg['final'];\n      var fsm       = target || cfg.target  || {};\n      var events    = cfg.events || [];\n      var callbacks = cfg.callbacks || {};\n      var map       = {};\n      var name;\n\n      var add = function(e) {\n        var from = (e.from instanceof Array) ? e.from : (e.from ? [e.from] : [StateMachine.WILDCARD]); // allow 'wildcard' transition if 'from' is not specified\n        map[e.name] = map[e.name] || {};\n        for (var n = 0 ; n < from.length ; n++)\n          map[e.name][from[n]] = e.to || from[n]; // allow no-op transition if 'to' is not specified\n      };\n\n      if (initial) {\n        initial.event = initial.event || 'startup';\n        add({ name: initial.event, from: 'none', to: initial.state });\n      }\n\n      for(var n = 0 ; n < events.length ; n++)\n        add(events[n]);\n\n      for(name in map) {\n        if (map.hasOwnProperty(name))\n          fsm[name] = StateMachine.buildEvent(name, map[name]);\n      }\n\n      for(name in callbacks) {\n        if (callbacks.hasOwnProperty(name))\n          fsm[name] = callbacks[name];\n      }\n\n      fsm.current = 'none';\n      fsm.is      = function(state) { return (state instanceof Array) ? (state.indexOf(this.current) >= 0) : (this.current === state); };\n      fsm.can     = function(event) { return !this.transition && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD)); };\n      fsm.cannot  = function(event) { return !this.can(event); };\n      fsm.error   = cfg.error || function(name, from, to, args, error, msg, e) { throw e || msg; }; // default behavior when something unexpected happens is to throw an exception, but caller can override this behavior if desired (see github issue #3 and #17)\n\n      fsm.isFinished = function() { return this.is(terminal); };\n\n      if (initial && !initial.defer)\n        fsm[initial.event]();\n\n      return fsm;\n\n    },\n\n    //===========================================================================\n\n    doCallback: function(fsm, func, name, from, to, args) {\n      if (func) {\n        try {\n          return func.apply(fsm, [name, from, to].concat(args));\n        }\n        catch(e) {\n          return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, 'an exception occurred in a caller-provided callback function', e);\n        }\n      }\n    },\n\n    beforeAnyEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm.onbeforeevent,                       name, from, to, args); },\n    afterAnyEvent:   function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm.onafterevent || fsm.onevent,      name, from, to, args); },\n    leaveAnyState:   function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm.onleavestate,                        name, from, to, args); },\n    enterAnyState:   function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm.onenterstate || fsm.onstate,      name, from, to, args); },\n    changeState:     function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm.onchangestate,                       name, from, to, args); },\n\n    beforeThisEvent: function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onbefore' + name],                     name, from, to, args); },\n    afterThisEvent:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onafter'  + name] || fsm['on' + name], name, from, to, args); },\n    leaveThisState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onleave'  + from],                     name, from, to, args); },\n    enterThisState:  function(fsm, name, from, to, args) { return StateMachine.doCallback(fsm, fsm['onenter'  + to]   || fsm['on' + to],   name, from, to, args); },\n\n    beforeEvent: function(fsm, name, from, to, args) {\n      if ((false === StateMachine.beforeThisEvent(fsm, name, from, to, args)) ||\n          (false === StateMachine.beforeAnyEvent( fsm, name, from, to, args)))\n        return false;\n    },\n\n    afterEvent: function(fsm, name, from, to, args) {\n      StateMachine.afterThisEvent(fsm, name, from, to, args);\n      StateMachine.afterAnyEvent( fsm, name, from, to, args);\n    },\n\n    leaveState: function(fsm, name, from, to, args) {\n      var specific = StateMachine.leaveThisState(fsm, name, from, to, args),\n          general  = StateMachine.leaveAnyState( fsm, name, from, to, args);\n      if ((false === specific) || (false === general))\n        return false;\n      else if ((StateMachine.ASYNC === specific) || (StateMachine.ASYNC === general))\n        return StateMachine.ASYNC;\n    },\n\n    enterState: function(fsm, name, from, to, args) {\n      StateMachine.enterThisState(fsm, name, from, to, args);\n      StateMachine.enterAnyState( fsm, name, from, to, args);\n    },\n\n    //===========================================================================\n\n    buildEvent: function(name, map) {\n      return function() {\n\n        var from  = this.current;\n        var to    = map[from] || map[StateMachine.WILDCARD] || from;\n        var args  = Array.prototype.slice.call(arguments); // turn arguments into pure array\n\n        if (this.transition)\n          return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, 'event ' + name + ' inappropriate because previous transition did not complete');\n\n        if (this.cannot(name))\n          return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, 'event ' + name + ' inappropriate in current state ' + this.current);\n\n        if (false === StateMachine.beforeEvent(this, name, from, to, args))\n          return StateMachine.Result.CANCELLED;\n\n        if (from === to) {\n          StateMachine.afterEvent(this, name, from, to, args);\n          return StateMachine.Result.NOTRANSITION;\n        }\n\n        // prepare a transition method for use EITHER lower down, or by caller if they want an async transition (indicated by an ASYNC return value from leaveState)\n        var fsm = this;\n        this.transition = function() {\n          fsm.transition = null; // this method should only ever be called once\n          fsm.current = to;\n          StateMachine.enterState( fsm, name, from, to, args);\n          StateMachine.changeState(fsm, name, from, to, args);\n          StateMachine.afterEvent( fsm, name, from, to, args);\n          return StateMachine.Result.SUCCEEDED;\n        };\n        this.transition.cancel = function() { // provide a way for caller to cancel async transition if desired (issue #22)\n          fsm.transition = null;\n          StateMachine.afterEvent(fsm, name, from, to, args);\n        };\n\n        var leave = StateMachine.leaveState(this, name, from, to, args);\n        if (false === leave) {\n          this.transition = null;\n          return StateMachine.Result.CANCELLED;\n        }\n        else if (StateMachine.ASYNC === leave) {\n          return StateMachine.Result.PENDING;\n        }\n        else {\n          if (this.transition) // need to check in case user manually called transition() but forgot to return StateMachine.ASYNC\n            return this.transition();\n        }\n\n      };\n    }\n\n  }; // StateMachine\n\n\n//# sourceURL=webpack://RadarClient/./node_modules/sfsm/state-machine.js?");

/***/ }),

/***/ "engine.io-client":
/*!**********************!*\
  !*** external "eio" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = eio;\n\n//# sourceURL=webpack://RadarClient/external_%22eio%22?");

/***/ }),

/***/ "minilog":
/*!**************************!*\
  !*** external "Minilog" ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Minilog;\n\n//# sourceURL=webpack://RadarClient/external_%22Minilog%22?");

/***/ })

/******/ });